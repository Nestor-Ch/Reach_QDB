od$save_rds(Database_questions, "Documents/Questions_db/Database_questions.rds")
# Optional: Provide a confirmation message
showModal(
modalDialog(
title = "Table Saved",
"The table has been saved into the QNR database.",
footer = NULL,
easyClose = TRUE
)
)
# reset the view once the user clicks the save button
save_needed(TRUE)
})
# Question browser block -----------------------------------------------------------
# Button logic block
# Code the actions when user selects one of the choices and clicks the button to update
# Middle column of the UI - browsing through the surveys
# if the user selected a dropdown option - trigger the value
dropdown_selected <-
reactiveVal(FALSE)  # Reactive value to track if button is clicked
observeEvent(input$dropdown, {
dropdown_selected(TRUE)
})
# if the user wants to compare something - trigger the value
comparison_needed <-
reactiveVal(FALSE)  # Reactive value to track if button is clicked
observeEvent(input$Filter_tables, {
downloadReady(FALSE)
comparison_needed(TRUE)  # Set the reactive value to TRUE when button is clicked
})
# top right section of the UI - if the reset is needed the previous buttons get turned off
# if the user wants to reset - trigger the value
reset_needed <-
reactiveVal(FALSE)  # Reactive value to track if button is clicked
observeEvent(input$Reset_data, {
reset_needed(TRUE)
# transform into False so that only the needed table is displayed
dropdown_selected(FALSE)
comparison_needed(FALSE)
downloadReady(FALSE)
})
# Top Left section of the UI - if the person wants to refresh the data - all other buttons turn off
downloadReady <-
reactiveVal(FALSE)  # Reactive value to track if button is clicked
observeEvent(input$Download_data, {
downloadReady(FALSE)# Set the reactive value to FALSE when button is clicked (allows the functionality of refreshing)
# transform into False so that only the needed table is displayed
reset_needed(FALSE)
dropdown_selected(FALSE)
comparison_needed(FALSE)
downloadReady(TRUE)# Set the reactive value to TRUE when button is clicked
})
# provide the input for the select DB dropdown list in the inputs
choices <- reactive({
if (downloadReady()) {
database_proj <- od$load_rds("Documents/Questions_db/Project_database.rds")
c('Select a project', unique(database_proj$Project_ID))
} else {
database_proj <-od$load_rds("Documents/Questions_db/Project_database.rds")
c('Select a project', unique(database_proj$Project_ID))
}
})
output$Comparison_input <- renderUI({
choices_list <- choices()
selectInput("dropdown",
"Select an option:",
choices = choices_list,
selected = 'Select a project')
})
# get the data from the db
output$table3 <- renderDT({
data.frame()
data <- od$load_rds("Documents/Questions_db/Project_database.rds") %>%
arrange(desc(as.numeric(round_id))) %>%
group_by(Project_ID) %>%
distinct(true_ID, .keep_all = T) %>%
ungroup() %>%
select(-merger_column) %>%
mutate(across(c(sector,Project_ID,question_type,survey_type, round_id), ~ as.factor(.x))) %>%
relocate(sector,Project_ID,round_id,survey_type,question_type)
if (is.null(data)) {
# Return an empty datatable if data is not available
DT::datatable(data)
} else if (downloadReady()) {
# if the refresh button was clicked - download the latest table
data <-od$load_rds("Documents/Questions_db/Project_database.rds") %>%
arrange(desc(as.numeric(round_id))) %>%
group_by(Project_ID) %>%
distinct(true_ID, .keep_all = T) %>%
ungroup() %>%
select(-merger_column) %>%
mutate(across(c(sector,Project_ID,question_type,survey_type, round_id), ~ as.factor(.x))) %>%
relocate(sector,Project_ID,round_id,survey_type,question_type)
DT::datatable(
data,
filter = "top",
extensions = 'Buttons',
options = list(
dom = 'lfrtipB',
buttons = c("copy", "csv", "pdf"),
pageLength = 100,
scrollX=TRUE,
autoWidth = TRUE,
columnDefs = list(
list(targets = 'true_ID', visible = FALSE),
list(width = '350px', targets = c('database_label_clean','label_english_choices','label_ukrainian',
'label_ukrainian_choices','label_russian','label_russian_choices')),
list(width = '120px', targets = c('sector'))
)
)
)
}
# if the user selected one of the dropdown options and requested a comparison - run this
else if (dropdown_selected() &
comparison_needed() & !is.null(data)) {
# get the selected ID of the survey
selectedOption <- input$dropdown
# Get the True_IDs of questions in the selected survey
unique_id <-
unique(data[data$Project_ID %in% selectedOption, ]$true_ID)
# build the dataset for comparison
data_comp <-  data[data$true_ID %in% unique_id, ]
# keep only those questions also present in other surveys
data_comp <- data_comp %>%
group_by(true_ID) %>%
mutate(cnt = n()) %>%
ungroup() %>%
filter(cnt > 1)
if(nrow(data_comp)==0){
showModal(
modalDialog(
title = "No matches found",
"This survey has no matching questions with other ones.",
footer = NULL,
easyClose = TRUE
)
)
}
# order the questions so that they're easier to read
data_comp <-
data_comp[order(data_comp$true_ID,
sub(selectedOption, " ", data_comp$Project_ID)),]
# keep only what's needed
data_comp <- data_comp %>% select(-c(true_ID, cnt))
# I want the rows with the selected project_id to be bold, so here I'm getting their row IDs
bold_rows <- which(data_comp$Project_ID %in% selectedOption)
DT::datatable(
data_comp,
filter = "top",
extensions = 'Buttons',
options = list(
dom = 'lfrtipB',
buttons = c("copy", "csv", "pdf"),
scrollX=TRUE,
autoWidth = TRUE,
columnDefs = list(
list(width = '350px', targets = c('database_label_clean','label_english_choices','label_ukrainian',
'label_ukrainian_choices','label_russian','label_russian_choices')),
list(width = '120px', targets = c('sector'))
),
pageLength = 100
)
) %>% formatStyle(
0,
target = "row",
fontWeight = styleEqual(bold_rows, "bold"),
#here we specify which rows we're making bold
`font-size` = "14px"
)
} else  if (!is.null(data) |  reset_needed()) {
# Render the datatable with column definitions
DT::datatable(
data,
filter = "top",
extensions = 'Buttons',
options = list(
dom = 'lfrtipB',
buttons = c("copy", "csv", "pdf"),
pageLength = 100,
scrollX=TRUE,
autoWidth = TRUE,
columnDefs = list(
list(targets = 'true_ID', visible = FALSE),
list(width = '350px', targets = c('database_label_clean','label_english_choices','label_ukrainian',
'label_ukrainian_choices','label_russian','label_russian_choices')),
list(width = '120px', targets = c('sector'))
)
)
)
}
})
############################################################################################################
#                                                     MAP                                                  #
############################################################################################################
########## Country map in the Input data page ##########
output$country_choice <- renderLeaflet({
choose_country_map
})
observeEvent(input$country_choice_shape_click, {
new_selected <- req(input$country_choice_shape_click)
isolate(old_selected <- rv$selected)
if(is_empty(rounds())){
}else{
if( !input$country_choice_shape_click$id %in% rv$oblasts){
rv$selected <- new_selected
rv$oblasts <- c(rv$oblasts,input$country_choice_shape_click$id)
oblast_iso <- ukraine %>%
filter(ADM_PCODE %in% rv$oblasts)
leafletProxy("country_choice") %>%
clearGroup("selection") %>%
addPolygons(data = oblast_iso,
fillColor = "#EE5859",
color = "#FFFFFF",
fillOpacity = 1,
label = ~oblast_iso$ADM_PCODE,
group = "selection",
layerId = ~oblast_iso$ADM_PCODE)
} else{
rv$selected <- new_selected
rv$oblasts <- setdiff(rv$oblasts,input$country_choice_shape_click$id)
oblast_iso <- ukraine %>%
filter(!ADM_PCODE %in% rv$oblasts)
leafletProxy("country_choice") %>%
addPolygons(data = oblast_iso,
fillColor  = "black",
color = "#FFFFFF",
weight= 1,
fillOpacity = 0.8,
highlightOptions = highlightOptions(
fillColor = "#aaaaaa",
color = "#aaaaaa",
weight = 2,
bringToFront = T
),
label = ~oblast_iso$ADM_PCODE,
layerId = ~oblast_iso$ADM_PCODE)
}
}
})
########## Reactive values ##########
rv <- reactiveValues()
rv$selected <- NULL
rv$oblasts <- NULL
########## Project ID OUtput ##########
output$project_id <- renderUI({
# bookmark this stage of the session
session$doBookmark()
project_table <- od$load_rds("Documents/Questions_db/Project_database.rds")
list_project <- project_table %>%
as.data.frame() %>%
pull(Project_ID) %>% unique
selectInput("project_id_selected", "Select Project ID",
choices = c(list_project))
})
rounds <- reactive({
project_table <- od$load_rds("Documents/Questions_db/Project_database.rds")
rounds <- project_table %>%
as.data.frame() %>%
filter(Project_ID == input$project_id_selected) %>% #'UKR2206B'
arrange(as.numeric(round_id)) %>%
pull(round_id) %>%  unique
map_table <-od$load_rds("Documents/Questions_db/map_table.rds") %>%
filter(Project_ID == input$project_id_selected) %>% #input$project_id_selected
pull(round_id) %>% unique
rounds <- setdiff(rounds,map_table)
return(rounds)
})
# this bit allows the user to return to the 'Geographical Input' tab after clicking the update button
# it takes too long so I'm not using it
# observe({
#   params <- parseQueryString(session$clientData$url_search)
#   if ("tab_index" %in% names(params)) {
#     updateTabsetPanel(session, "Tabpanel", selected = params$tab_index)
#   }
# })
# this bit of Java reloads the page
observeEvent(input$upload, {
isolate(shinyjs::runjs("
location.reload(true);
"))
})
# this bit updates the client browser to the bookmarked state
onBookmarked(function(url) {
updateQueryString(url, mode = 'replace')
})
output$round <- renderUI({
req(input$project_id_selected)
if(is_empty(rounds())) {
HTML(paste0("<p>All rounds for ",input$project_id_selected, " are uploaded"))
} else {
selectInput("round_selected", "Select Round",
choices = c(rounds()))
}
})
output$month <- renderUI({
req(input$project_id_selected,
input$round_selected)
months <- c("January", "February", "March", "April",
"May", "June", "July", "August",
"September", "October", "November", "December")
map_table <- od$load_rds("Documents/Questions_db/map_table.rds") %>%
filter(Project_ID == input$project_id_selected) %>%
pull(month) %>% unique
months <- setdiff(months,map_table)
if(is_empty(rounds())) {
} else {
selectInput("month_selected", "Select Month",
choices = months)
}
})
output$year <- renderUI({
req(input$project_id_selected,
input$round_selected,
input$month_selected)
years <- 2014:as.numeric(format(Sys.Date(),"%Y"))
map_table <- od$load_rds("Documents/Questions_db/map_table.rds")%>%
filter(Project_ID == input$project_id_selected)%>%
distinct(year,month) %>% ## change to input$project_id_selected
group_by(year,month)%>%
summarise(n = n()) %>%
filter(n == 12) %>%
pull(year) %>% unique
years <- setdiff(years,map_table)
if(is_empty(rounds())) {
} else {
selectInput("year_selected", "Select Year",
choices = years)
}
})
# read the new map table
map_table <- reactive({
req(input$project_id_selected,
input$round_selected,
input$month_selected,
input$year_selected,
rv$oblasts)
# build a dataframe out of it
map_table <- data.frame(Project_ID = input$project_id_selected,
round_id = input$round_selected,
month = input$month_selected,
year = input$year_selected,
PCODE = rv$oblasts)
# get the sectors from the Project_database
project_table <- od$load_rds("Documents/Questions_db/Project_database.rds") %>%
select(Project_ID, round_id, sector) %>%
# mutate(round_id = as.numeric(round_id)) %>%
distinct() %>%
filter(sector != "",
!is.na(sector))
# get the nice names for every assessment (from research cycle tracker)
assessment_name <- project_table() %>%
select(Project_ID,Name) %>%
rename("Assessment_Name" = Name)
# merge map_table with the sector table, assessment name table and Ukraine geometry, + add a date column for the visual
map_table <- map_table %>%
left_join(project_table, by = c("Project_ID","round_id")) %>%
left_join(assessment_name, by = "Project_ID") %>%
left_join(ukraine %>%
select(ADM_PCODE,ADM_NAME, geometry),
by = c('PCODE'='ADM_PCODE')) %>%
mutate(date = paste0('01/',match(month, month.name),'/',year,' 01:00')) %>%
distinct()
# possible changes here ----------------------
return(map_table)
})
database <- reactive({
map_table <- map_table()
database_map_table <- od$load_rds("Documents/Questions_db/map_table.rds") %>%
as.data.frame()
database_map_table <- bind_rows(database_map_table,map_table) %>% distinct()
print(head(database_map_table))
return(database_map_table)
})
observeEvent(input$upload, {
database <- database()
map_table <- database %>% distinct()
assign("map_table",map_table,envir = globalenv())
if(nrow(map_table) > 0){
isolate(od$save_rds(map_table, "Documents/Questions_db/map_table.rds"))
}
new_selected <- req(input$country_choice_shape_click)
isolate(old_selected <- rv$selected)
rv$selected <- new_selected
oblast_iso <- ukraine %>%
filter(ADM_PCODE %in% rv$oblasts)
leafletProxy("country_choice")%>%
clearGroup("selection")  %>%
addPolygons(data = oblast_iso,
fillColor  = "black",
color = "#FFFFFF",
weight= 1,
fillOpacity = 0.8,
highlightOptions = highlightOptions(
fillColor = "#aaaaaa",
color = "#aaaaaa",
weight = 2,
bringToFront = T
),
label = ~oblast_iso$ADM_PCODE,
layerId = ~oblast_iso$ADM_PCODE)
# showModal(
#   modalDialog(
#     title = "Data uploaded to the workspace",
#     easyClose = TRUE
#   )
# )
rv$oblasts <- NULL
new_selected <- NULL
old_selected <- NULL
})
# output$test <- renderUI({
#   renderTable(map_table())
# })
output$uploadBTN <- renderUI({
req(input$project_id_selected,
input$round_selected,
input$month_selected,
input$year_selected,
rv$oblasts)
if(is_empty(rounds())) {
}else{
isolate(actionButton("upload", "Upload info",
# onclick = "doReload('Geographical Input')"
))
}
})
}
shinyApp(ui = ui, server = server, enableBookmarking = "url")
showLogs
??showLogs
rsconnect::showLogs(appName = 'ReachQDB', account = 'impact-initiatives')
rsconnect::showLogs(appName = 'Reach_QDB', account = 'impact-initiatives')
rsconnect::showLogs(appName = 'Reach_QDB', account = 'impact-initiatives')
rsconnect::showLogs(appName = 'Reach_QDB', account = 'impact-initiatives')
library(shiny); runApp('shiny_12_final_updates.R')
library(shiny); runApp('shiny_12_final_updates.R')
reticulate::py_config()
library(shiny); runApp('shiny_12_final_updates.R')
reticulate::virtualenv_create(envname = virtualenv_dir, python = python_path)
runApp('shiny_12_final_updates.R')
help(use_virtualenv)
reticulate::use_virtualenv(python_path, required = T)
runApp('shiny_12_final_updates.R')
if(! grepl(Sys.getenv('VIRTUALENV_NAME'),reticulate::py_config()$virtualenv)){
reticulate::use_virtualenv(virtualenv_dir, required = T)
}
library(shiny)
library(shinyjs)
library(DT)
library(openxlsx)
library(dplyr)
library(tidyverse)
library(stringdist)
library(fuzzyjoin)
library(rhandsontable)
library(data.table)
library(ids)
library(sharepointR)
library(httr)
library(xml2)
library(curl)
library(tidytext)
library(leaflet)
library(leaflet.extras2)
library(sf)
# library(mapview)
# library(webshot)
source("www/src/STX_Utils_DB_app.R")
source('.Rprofile')
# to do ------------
# webshot::install_phantomjs(force = T)
options(shiny.maxRequestSize = 30 * 1024 ^ 2,
rsconnect.max.bundle.files = 5145728000)
# map setup
ukraine <- st_read("www/shapefile/Ukraine_Admin1.shp") %>%
st_simplify(preserveTopology = T, dTolerance = 3000)
choose_country_map <- leaflet::leaflet(
options = leafletOptions(
attributionControl = F,
zoomControl = F,
minZoom = 6, maxZoom = 6,
)) %>%
leaflet::addProviderTiles(providers$CartoDB.PositronNoLabels) %>%
leaflet::addPolygons(data= ukraine,
fillColor  = "black",
color = "#FFFFFF",
weight= 1,
fillOpacity = 0.8,
highlightOptions = highlightOptions(
fillColor = "#aaaaaa",
color = "#aaaaaa",
weight = 2,
bringToFront = T
),
label = ~ukraine$ADM_NAME,
layerId = ~ukraine$ADM_PCODE)%>%
setView(lng = 31.14869, lat = 48.5, zoom = 6)
# Python Setup
PYTHON_DEPENDENCIES = c('pip', 'numpy','pandas','spacy')
virtualenv_dir = Sys.getenv('VIRTUALENV_NAME')
python_path = Sys.getenv('PYTHON_PATH')
# Create virtual env and install dependencies
if(!virtualenv_dir %in% reticulate::virtualenv_list()){
reticulate::virtualenv_create(envname = virtualenv_dir, python = python_path)
}
if(! grepl(Sys.getenv('VIRTUALENV_NAME'),reticulate::py_config()$virtualenv)){
reticulate::use_virtualenv(virtualenv_dir, required = T)
}
virtualenv_dir
Sys.getenv(PYTHON_PATH)
Sys.getenv('PYTHON_PATH')
Sys.getenv('PYTHON_PATH')
